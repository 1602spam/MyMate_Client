2022-10-25

1. 작업한 기능
	a. 수신 데이터가 발생할 시 SvcDistributor가 수신 큐의 오브젝트를 각 오브젝트 컨테이너로 옮기는 구조
	b. 모델 클래스 완성
	c. 컨테이너 구조 구현(데이터 생성, 수정, 조회 테스트 완료, 삭제도 당연히 가능할 것으로 보임)
	d. 쿼리문으로 컨테이너로부터 오브젝트를 가져와 내용 출력 가능
	e. 윈폼 컴포넌트에 대한 갱신이 이루어질 수 있는 구조 고안
2. 작업중인 기능
	a. 모델 클래스에 생성된 시각 저장하는 속성 부여
	b. 프로토콜 작업이 완성되면 모든 오브젝트에 대해 distributor에서 분배하는 기능 구현
3. 작업할 기능
	a. 윈폼 모듈로 연결
	b. ini 설정 파일 구성 서비스 구현(후순위)

Notes:
	해당 폼 페이지에 단발적인 시나리오 메서드를 구성하거나,
	여러 폼에서 자주 호출해야 하는 시나리오의 경우 컨트롤러 클래스를 만들어서 구성할 것
	(예로 친구 목록을 불러온다: loadFriendList(int usercode) ...)
	컨테이너로부터 끌어오는 식으로 구성될 것

	데이터의 수정 삭제는 그냥 하면 되지만
	연결된 컴포넌트의 수정 삭제 때문에 버그가 발생할 가능성이 높으므로 생성 및 조회 우선 작업

	데이터를 컴포넌트에 넣고 생성해주는 것 자체는 문제 없을 것으로 보임

	컴포넌트가 반복적으로 생성되는 경우 유저 컨트롤로 구성한 다음
	해당 페이지의 딕셔너리<코드,오브젝트>를 통해 관리

	수신 큐에 뭐가 들어옴 ->
	distributor가 수신 큐에 있는 걸 검사해서 각 오브젝트 컨테이너에 넣음 ->

	폼에는
	a. 코드/컴포넌트 딕셔너리
	b. (폼 시작 시)엑셀 파일로부터 내용을 불러오는 메서드
	c. (폼 시작 시/컨테이너에 넣은 걸 감지할 시)해당 딕셔너리 밸류를 가지고 모두 출력하는 메서드
	option: 동적인 수정 삭제를 구현하게 되면, 수정된 코드를 가진 컴포넌트만 갱신하는 메서드

	다시 정리:

	유저 컨트롤의 생성을 위해: container의 오브젝트 내용을 가져와 새로 만들어 딕셔너리에 넣어 줍니다.
	데이터 수신이 발생할 때마다: 수신한 오브젝트를 사용하는 딕셔너리에서 변화를 감지해 value의 속성을 변경합니다.
	구현을 위해: 오브젝트 별로 딕셔너리와 변화 감지 및 처리 메서드가 포함된 클래스를 구성해서 폼에서 가져야 합니다.
	
	그 클래스는 ViewObject와 같은 이름으로 구성할 것

-----------
2022-10-26

1. winform 환경에서 컨테이너의 내용을 불러오고 특정 데이터를 검색해서 수정하고 수정사항을 반영하는 프로그램 테스트 완료

2. Invoke, 이벤트 처리, 모델 클래스쪽에 생성 시간 속성 추가해서 송수신에 대해 1번처럼 작동할 수 있으면 갖다 붙이기만 하면 됨

	수신 큐에 뭐가 들어옴 ->
	이벤트 호출되면 distributor가 수신 큐에 있는 걸 검사해서 각 오브젝트 컨테이너에 넣음 ->
	폼마다 해당 컨테이너를 참조하는 딕셔너리<int,object>, 혹은 linked list가 있고,
	컨테이너 이벤트 속성에 Invoke로 컴포넌트들을 갱신하고 다시 그려 주는 함수를 넣어 줌

	메시지는 시간 오름차순으로 정렬되고, 최초 50개 불러오고 스크롤을 올릴 때마다 25개씩 불러온다고 하고
	파일 입출력으로 불러온 데이터가 수정되었는지 여부는, 로그인 시 마지막으로 받은 패킷의 시간값 대조해서 가져옴
-----------
2022-10-30

1. 따라잡기
distributor에서 오브젝트를 컨테이너에 넣어 줌
컨테이너 이벤트를 컨테이너 접근 시마다 호출
폼에서 오브젝트 딕셔너리를 갖고 있고, 폼 시작 시에 컨테이너 인스턴스 이벤트에 메서드 추가
그때 메서드 내용은 Invoke로 컴포넌트 데이터를 갱신하고 다시 그려 주는 것

-----------
2022-10-31

변경사항
1. 이벤트 처리 완료
2. 소단위 모델 컨테이너가 상위 모델 속성으로 들어감
할것
1. IContainer에 등록된 에러 이벤트를 모든 컨테이너에 등록하기
2. distributor에서 각 키에 대한 케이스 처리
3. 모든 모델에 널체크(코드값 혹은 시간값 0인 것)
4. 모든 모델에 프로토콜 인수로 한 생성자 만들고 값 초기화
5. 딕셔너리 넣을 때 키값으로 들어오는 건 유저코드 빼고 다 내 쪽에서 출력 순서 만들려고 임의로 부여하기
-----------
2022-11-02

한것
1. 리스트 저장 방식
2. 로컬에서 생성자 조회
3. 구조 변경에 따라 소단위 컨테이너의 ConcurrentDictionary를 List로 대체하고
	AddOrUpdate는 시퀀스 속성값을 가지고 비교해서 갱신하는 것으로 대체
	{
	널체크
	카운트 0일 시 넣기
	동일 속성 원소 찾아서 있으면 대체
	없으면 넣기
	}
4. 로그인 시 처음 생성되는 유저(나) 코드값은 UserContainer.Instance.MyCode에 저장함
5. 상위 컨테이너에 하위 컨테이너 아이템 한번에 조회하는 함수 만들기
6. 임시 테스트 합격

할것
0. 상세한 건 거슬리면 변경하기로 하고
	모든 컨테이너에 대해 리스트 방식이면 리스트의 AddOrUpdate를 적용,
	모든 모델에 대해 distributor에서 관리
	모든 컨테이너에 대해 상위 컨테이너에 하위 컨테이너 아이템 한번에 조회하는 함수 만들기
1. 퍼미션 관련 속성은 주석 처리
2. 모든 모델에 프로토콜 인수로 한 생성자 만들기
3. 주석 추가, 사용 편리성 확보!
-----------
2022-11-03

할것
1. 윈폼 메시지 전송 테스트하기

로컬에서 스테이징 안 하기 때문에
엔터를 누르면 해당 메시지 정보를 보내고
다시 받아서 distributor에서 분배가 발생하면
메시지 컨테이너에 AddOrUpdate 시 이벤트가 발생하고 이벤트 파라미터로 넘겨줌

이벤트 발생 시 AddOrUpdate의 내용:
메시지 코드가 있다면 해당 메시지 정보가 본인 건지 확인 > Rchat/Lchat 리스트에서 텍스트만 수정하고,
새로운 메시지라면 유저코드가 본인인지 판단해서 LSend RSend에서 컴포넌트 리스트에 추가 및 화면에 표시

따라서 폼에 있어야 하는 것
1. 생성자와 폼 닫을 시 컨테이너 분배 이벤트에 AddOrUpdate 메서드 등록 / 오류 이벤트에 Error 메서드 등록(메시지 유효하지 않다고 콘솔에 출력)
2. 컴포넌트 리스트 List<Lchat> Lchats와 List<Rchat> Rchats 속성/ 컴포넌트 AddOrUpdate() / OnMessageReceiveError()
3. send 버튼을 누르면 유저정보와 메시지 정보를 가지고 MdlMessage를 만들어 보냄

메시지 컴포넌트에 있어야 하는 것
생성자로 MdlMessage를 받아 해당 객체 속성을 받아와 출력함

해야 할 것
send 및 서버의 응답 기능이 완성되지 않았으므로 distributor에 넣어주는 putItem 메서드를 사용해 테스트함
프로토콜이 완성되지 않았으므로 모델 속성을 그대로 받는 컴포넌트 생성자를 만들어 테스트함

로그인 -> 임의의 내 데이터 생성 -> 임의 상대 유저 생성 -> 임의 서버 생성 -> 임의 채팅방 생성 -> 임의 메시지 생성
서버와 채팅방을 누르면 진입하는 폼이 아직 구현 안 돼있기 때문에, 존재하는 서버와 채팅방, 유저의 이벤트 처리 및 메시지 컴포넌트 관리가 되는지 확인하는 게 전부

----------
2022-11-05
한것:
1. 클라이언트 서버-채널-메시지 전송 구조 윈폼 테스트 완료

할것:
1. 모든 모델 클래스 및 컨테이너에 프로토콜 속성 참조해서 처리 자동화: 11-06까지
2.
메시지 최대 글자수 제한/
24시간 내일 경우 다른 메시지 포맷/
엔터키로 전송 및 쉬프트+엔터로 줄바꿈/
전송 직후 텍스트박스 포커스/
리스트에서 위로 스크롤할 경우 상단으로 메시지 추가 로드하기/
메시지 우클릭 시 수정/삭제 옵션 띄우기+메시지에 IsVisible 속성 넣기/
좌측 하단 플러스 버튼 클릭 시 채널 공유/친구 추가 메시지 전송 옵션 띄우기 등의 채팅 페이지 관련 요구사항 검토: 11-07까지
3.
폼 작업 리스트에서 동일한 소규모 항목이 들어가는 List들은 FlowLayoutPanel, TableLayoutPanel, Panel 등 활용하고
Panel.Add 등으로 소규모 항목을 추가해주면 되기 때문에 별도의 유저컨트롤로 구성할 필요 없다는 의견 토의:11-08까지