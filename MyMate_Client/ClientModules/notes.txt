2022-10-25

1. 작업한 기능
	a. 수신 데이터가 발생할 시 SvcDistributor가 수신 큐의 오브젝트를 각 오브젝트 컨테이너로 옮기는 구조
	b. 모델 클래스 완성
	c. 컨테이너 구조 구현(데이터 생성, 수정, 조회 테스트 완료, 삭제도 당연히 가능할 것으로 보임)
	d. 쿼리문으로 컨테이너로부터 오브젝트를 가져와 내용 출력 가능
	e. 윈폼 컴포넌트에 대한 갱신이 이루어질 수 있는 구조 고안
2. 작업중인 기능
	a. 모델 클래스에 생성된 시각 저장하는 속성 부여
	b. 프로토콜 작업이 완성되면 모든 오브젝트에 대해 distributor에서 분배하는 기능 구현
3. 작업할 기능
	a. 윈폼 모듈로 연결
	b. ini 설정 파일 구성 서비스 구현(후순위)

Notes:
	해당 폼 페이지에 단발적인 시나리오 메서드를 구성하거나,
	여러 폼에서 자주 호출해야 하는 시나리오의 경우 컨트롤러 클래스를 만들어서 구성할 것
	(예로 친구 목록을 불러온다: loadFriendList(int usercode) ...)
	컨테이너로부터 끌어오는 식으로 구성될 것

	데이터의 수정 삭제는 그냥 하면 되지만
	연결된 컴포넌트의 수정 삭제 때문에 버그가 발생할 가능성이 높으므로 생성 및 조회 우선 작업

	데이터를 컴포넌트에 넣고 생성해주는 것 자체는 문제 없을 것으로 보임

	컴포넌트가 반복적으로 생성되는 경우 유저 컨트롤로 구성한 다음
	해당 페이지의 딕셔너리<코드,오브젝트>를 통해 관리

	수신 큐에 뭐가 들어옴 ->
	distributor가 수신 큐에 있는 걸 검사해서 각 오브젝트 컨테이너에 넣음 ->

	폼에는
	a. 코드/컴포넌트 딕셔너리
	b. (폼 시작 시)엑셀 파일로부터 내용을 불러오는 메서드
	c. (폼 시작 시/컨테이너에 넣은 걸 감지할 시)해당 딕셔너리 밸류를 가지고 모두 출력하는 메서드
	option: 동적인 수정 삭제를 구현하게 되면, 수정된 코드를 가진 컴포넌트만 갱신하는 메서드

	다시 정리:

	유저 컨트롤의 생성을 위해: container의 오브젝트 내용을 가져와 새로 만들어 딕셔너리에 넣어 줍니다.
	데이터 수신이 발생할 때마다: 수신한 오브젝트를 사용하는 딕셔너리에서 변화를 감지해 value의 속성을 변경합니다.
	구현을 위해: 오브젝트 별로 딕셔너리와 변화 감지 및 처리 메서드가 포함된 클래스를 구성해서 폼에서 가져야 합니다.
	
	그 클래스는 ViewObject와 같은 이름으로 구성할 것

-----------
2022-10-26

1. winform 환경에서 컨테이너의 내용을 불러오고 특정 데이터를 검색해서 수정하고 수정사항을 반영하는 프로그램 테스트 완료

2. Invoke, 이벤트 처리, 모델 클래스쪽에 생성 시간 속성 추가해서 송수신에 대해 1번처럼 작동할 수 있으면 갖다 붙이기만 하면 됨

	수신 큐에 뭐가 들어옴 ->
	이벤트 호출되면 distributor가 수신 큐에 있는 걸 검사해서 각 오브젝트 컨테이너에 넣음 ->
	폼마다 해당 컨테이너를 참조하는 딕셔너리<int,object>, 혹은 linked list가 있고,
	컨테이너 이벤트 속성에 Invoke로 컴포넌트들을 갱신하고 다시 그려 주는 함수를 넣어 줌

	메시지는 시간 오름차순으로 정렬되고, 최초 50개 불러오고 스크롤을 올릴 때마다 25개씩 불러온다고 하고
	파일 입출력으로 불러온 데이터가 수정되었는지 여부는, 로그인 시 마지막으로 받은 패킷의 시간값 대조해서 가져옴
-----------
2022-10-30

1. 따라잡기
distributor에서 오브젝트를 컨테이너에 넣어 줌
컨테이너 이벤트를 컨테이너 접근 시마다 호출
폼에서 오브젝트 딕셔너리를 갖고 있고, 폼 시작 시에 컨테이너 인스턴스 이벤트에 메서드 추가
그때 메서드 내용은 Invoke로 컴포넌트 데이터를 갱신하고 다시 그려 주는 것

-----------
2022-10-31

변경사항
1. 이벤트 처리 완료
2. 소단위 모델 컨테이너가 상위 모델 속성으로 들어감
할것
1. IContainer에 등록된 에러 이벤트를 모든 컨테이너에 등록하기
2. distributor에서 각 키에 대한 케이스 처리
3. 모든 모델에 널체크(코드값 혹은 시간값 0인 것)
4. 모든 모델에 프로토콜 인수로 한 생성자 만들고 값 초기화
5. 딕셔너리 넣을 때 키값으로 들어오는 건 유저코드 빼고 다 내 쪽에서 출력 순서 만들려고 임의로 부여하기
-----------
2022-11-2

실수로 푸시 안해서 날아간 것
1. 리스트 저장 방식
2. 로컬에서 생성자 조회

할것
1. 구조 변경에 따라 소단위 컨테이너의 ConcurrentDictionary를 List로 대체하고
	AddOrUpdate는 시퀀스 속성값을 가지고 비교해서 갱신하는 것으로 대체
	{
	널체크
	카운트 0일 시 넣기
	동일 속성 원소 찾아서 있으면 대체
	없으면 넣기
	}
2. ScheduleItem의 경우
	스케줄 하나가 월별로 총 12개의 스케줄 리스트를 가지고 있고
	데이터 수신 시 통으로 받아서 월초, 월말에 잘리는 경우는 잘리는 만큼 나눠서 넣기
	{
	널체크
	스타트데이트와 엔드데이트 분석해서 쪼개 줌
	각 데이터를 월별 스위치로 돌려서
		카운트 0일 시 넣기
		동일 속성 원소 찾아서 있으면 대체
		없으면 넣기
	}
	데이터 송신 시 통으로 보냄
3. 로그인 시 처음 생성되는 유저(나) 코드값은 UserContainer.Instance.MyCode에 저장함
4. 상위 컨테이너에 하위 컨테이너 아이템 한번에 조회하는 함수 만들기
getItemByItem
5. 퍼미션 관련 속성은 주석 처리
6. 모든 데이터에 대해 생성/수정 테스트 하기(테스트 케이스 작성)
7. 모든 모델에 프로토콜 인수로 한 생성자 만들기
8. 주석 추가, 사용 편리성 확보